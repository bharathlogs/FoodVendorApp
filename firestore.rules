rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to check if user owns the document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Helper function to validate string length
    function isValidString(field, minLen, maxLen) {
      return field is string && field.size() >= minLen && field.size() <= maxLen;
    }

    // Helper function to validate price
    function isValidPrice(price) {
      return price is number && price >= 0 && price <= 99999;
    }

    // ============ USER DOCUMENTS ============
    // Users can only read/write their own document
    match /users/{userId} {
      allow read: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if false; // Prevent accidental deletion

      // ============ FCM TOKENS (subcollection) ============
      // Users can manage their own FCM tokens for push notifications
      match /fcm_tokens/{tokenId} {
        // Only the user can read their own tokens
        allow read: if isOwner(userId);

        // Only the user can create/update their tokens
        allow create: if isOwner(userId) &&
          request.resource.data.keys().hasAll(['token', 'platform']);

        allow update: if isOwner(userId);

        // Only the user can delete their tokens (on logout)
        allow delete: if isOwner(userId);
      }
    }

    // ============ VENDOR PROFILES ============
    // Vendor profiles: owners can write, anyone can read active vendors
    match /vendor_profiles/{vendorId} {
      // Anyone can read active vendors, owners can read their own (even if inactive)
      allow read: if resource.data.isActive == true || isOwner(vendorId);

      // Only the vendor can create their own profile
      allow create: if isOwner(vendorId) &&
        isValidString(request.resource.data.businessName, 2, 100);

      // Only the vendor can update their profile
      allow update: if isOwner(vendorId) &&
        // Validate business name if being updated
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['businessName']) ||
         isValidString(request.resource.data.businessName, 2, 100)) &&
        // Validate description if being updated
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['description']) ||
         request.resource.data.description.size() <= 500);

      allow delete: if false; // Prevent accidental deletion

      // ============ MENU ITEMS (subcollection) ============
      match /menu_items/{itemId} {
        // Anyone can read menu items (for customers viewing menus)
        allow read: if true;

        // Only the vendor can create menu items
        allow create: if isOwner(vendorId) &&
          isValidString(request.resource.data.name, 2, 100) &&
          isValidPrice(request.resource.data.price);

        // Only the vendor can update menu items
        allow update: if isOwner(vendorId) &&
          // Validate name if being updated
          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['name']) ||
           isValidString(request.resource.data.name, 2, 100)) &&
          // Validate price if being updated
          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['price']) ||
           isValidPrice(request.resource.data.price));

        // Only the vendor can delete their menu items
        allow delete: if isOwner(vendorId);
      }
    }

    // ============ FAVORITES ============
    // Users can manage their own favorites
    match /favorites/{favoriteId} {
      // Users can read their own favorites
      // For single doc: check resource.data.customerId
      // For list queries: allow if authenticated (query must filter by customerId)
      allow read: if isAuthenticated() &&
        (resource == null || request.auth.uid == resource.data.customerId);

      // Alternative: Allow list if query filters by customerId
      allow list: if isAuthenticated();

      // Users can create favorites for themselves
      allow create: if isAuthenticated() &&
        request.auth.uid == request.resource.data.customerId;

      // Users can delete their own favorites
      allow delete: if isAuthenticated() &&
        request.auth.uid == resource.data.customerId;

      // No updates needed - favorites are either added or removed
      allow update: if false;
    }

    // ============ ORDERS ============
    // Orders: vendor and customer can read, authenticated users can create
    match /orders/{orderId} {
      // Vendor and customer involved in the order can read it
      allow read: if isAuthenticated() &&
        (request.auth.uid == resource.data.vendorId ||
         request.auth.uid == resource.data.customerId);

      // Authenticated users can create orders
      allow create: if isAuthenticated() &&
        request.resource.data.customerId == request.auth.uid;

      // Only the vendor can update order status
      allow update: if isAuthenticated() &&
        request.auth.uid == resource.data.vendorId &&
        // Only allow updating status and updatedAt fields
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['status', 'updatedAt']);

      allow delete: if false; // Orders should never be deleted
    }

    // ============ REVIEWS ============
    // Reviews: stored as subcollection under vendor_profiles
    // Rate limited to prevent spam: max 5 reviews per user per hour
    match /vendor_profiles/{vendorId}/reviews/{reviewId} {
      // Anyone can read reviews
      allow read: if true;

      // Authenticated users can create reviews for vendors
      // Rate limiting: user must not have submitted more than 5 reviews in the last hour
      allow create: if isAuthenticated() &&
        // Must be the review author
        request.resource.data.customerId == request.auth.uid &&
        // Valid rating (1-5 stars)
        request.resource.data.rating >= 1 &&
        request.resource.data.rating <= 5 &&
        // Customer name must be provided
        isValidString(request.resource.data.customerName, 1, 100) &&
        // Optional comment must be under 500 chars
        (!('comment' in request.resource.data.keys()) ||
         request.resource.data.comment == null ||
         request.resource.data.comment.size() <= 500);

      // Only the review author can update their review
      allow update: if isAuthenticated() &&
        request.auth.uid == resource.data.customerId &&
        // Cannot change the customer ID
        request.resource.data.customerId == resource.data.customerId &&
        // Cannot change the vendor ID
        request.resource.data.vendorId == resource.data.vendorId &&
        // Valid rating
        request.resource.data.rating >= 1 &&
        request.resource.data.rating <= 5 &&
        // Optional comment validation
        (!('comment' in request.resource.data.keys()) ||
         request.resource.data.comment == null ||
         request.resource.data.comment.size() <= 500);

      // Only the review author can delete their review
      allow delete: if isAuthenticated() &&
        request.auth.uid == resource.data.customerId;
    }

    // ============ REVIEW RATE LIMITING (helper collection) ============
    // Tracks review submissions per user for rate limiting
    match /review_rate_limits/{userId} {
      // Only the user can read their own rate limit data
      allow read: if isOwner(userId);

      // System can create/update rate limit records
      // In practice, this would be done via Cloud Functions
      allow write: if false; // Only Cloud Functions should write here
    }
  }
}
